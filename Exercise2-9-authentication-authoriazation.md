![Revisit consent button](https://cdn-cookieyes.com/assets/images/revisit.svg)

We value your privacy

We use cookies to enhance your browsing experience, serve personalised ads or content, and analyse our traffic. By clicking "Accept All", you consent to our use of cookies.

![cky-close-icon](https://cdn-cookieyes.com/assets/images/close.svg)

We use cookies to help you navigate efficiently and perform certain functions. You will find detailed information about all cookies under each consent category below.

The cookies that are categorised as "Necessary" are stored on your browser as they are essential for enabling the basic functionalities of the site. ... Show more

For more information on how Google's third-party cookies operate and handle your data, see: [Google Privacy Policy](https://business.safety.google/privacy)

Necessary cookies are required to enable the basic features of this site, such as providing secure log-in or adjusting your consent preferences. These cookies do not store any personally identifiable data.


- Cookie__cf_uuid
- Duration1 year 1 month 4 days
- DescriptionDescription is currently not available.


- Cookielanding_page
- Duration1 hour
- DescriptionThe _landing_page cookie tracks the first page a user visits on a website, helping to analyze user behavior and optimize the site's performance.


- Cookie__cf_bm
- Duration1 hour
- DescriptionThis cookie, set by Cloudflare, is used to support Cloudflare Bot Management.


- Cookie_cfuvid
- Durationsession
- DescriptionCalendly sets this cookie to track users across sessions to optimize user experience by maintaining session consistency and providing personalized services


- Cookie__hssrc
- Durationsession
- DescriptionThis cookie is set by Hubspot whenever it changes the session cookie. The __hssrc cookie set to 1 indicates that the user has restarted the browser, and if the cookie does not exist, it is assumed to be a new session.


- Cookie__hssc
- Duration1 hour
- DescriptionHubSpot sets this cookie to keep track of sessions and to determine if HubSpot should increment the session number and timestamps in the __hstc cookie.


- CookieOptanonConsent
- Duration1 year
- DescriptionOneTrust sets this cookie to store details about the site's cookie category and check whether visitors have given or withdrawn consent from the use of each category.


- CookiewpEmojiSettingsSupports
- Durationsession
- DescriptionWordPress sets this cookie when a user interacts with emojis on a WordPress site.  It helps determine if the user's browser can display emojis properly.


- CookieYSC
- Durationsession
- DescriptionYoutube sets this cookie to track the views of embedded videos on Youtube pages.


- CookieVISITOR_INFO1_LIVE
- Duration6 months
- DescriptionYouTube sets this cookie to measure bandwidth, determining whether the user gets the new or old player interface.


- CookieVISITOR_PRIVACY_METADATA
- Duration6 months
- DescriptionYouTube sets this cookie to store the user's cookie consent state for the current domain.


- Cookie__utmz
- Duration6 months
- DescriptionGoogle Analytics sets this cookie to store the traffic source or campaign by which the visitor reached the site.


- Cookie_coach_session
- Durationsession
- DescriptionNo description available.


- Cookie__cfruid
- Durationsession
- DescriptionCloudflare sets this cookie to identify trusted web traffic.


- Cookiem
- Duration1 year 1 month 4 days
- DescriptionStripe sets this cookie for fraud prevention purposes. It identifies the device used to access the website, allowing the website to be formatted accordingly.


- Cookieyt.innertube::requests
- DurationNever Expires
- DescriptionYouTube sets this cookie to register a unique ID to store data on what videos from YouTube the user has seen.


- Cookieyt.innertube::nextId
- DurationNever Expires
- DescriptionYouTube sets this cookie to register a unique ID to store data on what videos from YouTube the user has seen.


- Cookieyt-remote-device-id
- DurationNever Expires
- DescriptionYouTube sets this cookie to store the user's video preferences using embedded YouTube videos.


- Cookieytidb::LAST_RESULT_ENTRY_KEY
- DurationNever Expires
- DescriptionThe cookie ytidb::LAST_RESULT_ENTRY_KEY is used by YouTube to store the last search result entry that was clicked by the user. This information is used to improve the user experience by providing more relevant search results in the future.


- Cookieyt-remote-connected-devices
- DurationNever Expires
- DescriptionYouTube sets this cookie to store the user's video preferences using embedded YouTube videos.


- Cookieyt-remote-session-app
- Durationsession
- DescriptionThe yt-remote-session-app cookie is used by YouTube to store user preferences and information about the interface of the embedded YouTube video player.


- Cookieyt-remote-cast-installed
- Durationsession
- DescriptionThe yt-remote-cast-installed cookie is used to store the user's video player preferences using embedded YouTube video.


- Cookieyt-remote-session-name
- Durationsession
- DescriptionThe yt-remote-session-name cookie is used by YouTube to store the user's video player preferences using embedded YouTube video.


- Cookieyt-remote-fast-check-period
- Durationsession
- DescriptionThe yt-remote-fast-check-period cookie is used by YouTube to store the user's video player preferences for embedded YouTube videos.


- Cookie_calendly_session
- Duration21 days
- DescriptionCalendly, a Meeting Schedulers, sets this cookie to allow the meeting scheduler to function within the website and to add events into the visitor’s calendar.


- Cookiecookieyes-consent
- Duration1 year
- DescriptionCookieYes sets this cookie to remember users' consent preferences so that their preferences are respected on subsequent visits to this site. It does not collect or store any personal information about the site visitors.

Functional cookies help perform certain functionalities like sharing the content of the website on social media platforms, collecting feedback, and other third-party features.

No cookies to display.

Analytical cookies are used to understand how visitors interact with the website. These cookies help provide information on metrics such as the number of visitors, bounce rate, traffic source, etc.


- Cookielanding_page_1
- Duration1 day
- DescriptionDescription is currently not available.


- Cookielanding_page_30
- Duration1 month
- DescriptionDescription is currently not available.


- Cookiesource
- Duration1 day
- DescriptionDescription is currently not available.


- Cookiemedium
- Duration1 day
- DescriptionNo description available.


- Cookiecontent
- Duration1 day
- DescriptionNo description available.


- Cookieterm
- Duration1 day
- DescriptionDescription is currently not available.


- Cookiecampaign
- Duration1 day
- DescriptionNo description available.


- Cookieconversion_page
- Duration1 day
- DescriptionNo description available.


- Cookie_omappvp
- Duration1 year 1 month 4 days
- DescriptionThe _omappvp cookie is set to distinguish new and returning users and is used in conjunction with _omappvs cookie.


- Cookie_omappvs
- Duration20 minutes
- DescriptionThe _omappvs cookie, used in conjunction with the _omappvp cookies, is used to determine if the visitor has visited the website before, or if it is a new visitor.


- Cookie__utmt_sfga
- Duration10 minutes
- DescriptionSet by Google Analytics and Google Tag Manager to enable website owners to track visitor behaviour and measure site performance.


- Cookie_ga_*
- Duration1 year 1 month 4 days
- DescriptionGoogle Analytics sets this cookie to store and count page views.


- Cookie_ga
- Duration1 year 1 month 4 days
- DescriptionGoogle Analytics sets this cookie to calculate visitor, session and campaign data and track site usage for the site's analytics report. The cookie stores information anonymously and assigns a randomly generated number to recognise unique visitors.


- Cookie_gid
- Duration1 day
- DescriptionGoogle Analytics sets this cookie to store information on how visitors use a website while also creating an analytics report of the website's performance. Some of the collected data includes the number of visitors, their source, and the pages they visit anonymously.


- Cookie_gat_UA-*
- Duration1 minute
- DescriptionGoogle Analytics sets this cookie for user behaviour tracking.


- Cookie__hstc
- Duration6 months
- DescriptionHubspot set this main cookie for tracking visitors. It contains the domain, initial timestamp (first visit), last timestamp (last visit), current timestamp (this visit), and session number (increments for each subsequent session).


- Cookiehubspotutk
- Duration6 months
- DescriptionHubSpot sets this cookie to keep track of the visitors to the website. This cookie is passed to HubSpot on form submission and used when deduplicating contacts.


- Cookie_fbp
- Duration3 months
- DescriptionFacebook sets this cookie to display advertisements when either on Facebook or on a digital platform powered by Facebook advertising after visiting the website.


- Cookie__utma
- Duration1 year 1 month 4 days
- DescriptionGoogle Analytics sets this cookie to distinguish users and sessions. The cookie is created when the JavaScript library executes and there are no existing __utma cookies. The cookie is updated every time data is sent to Google Analytics.


- Cookie__utmc
- Durationsession
- DescriptionGoogle Analytics sets this cookie to enable interoperability with urchin.js, an older version of Google Analytics and is used in conjunction with the __utmb cookie to determine new sessions/visits. It is deleted when the user closes the browser.


- Cookie__utmb
- Duration1 hour
- DescriptionGoogle Analytics sets this cookie to determine new sessions/visits. __utmb cookie is created when the JavaScript library executes and there are no existing __utma cookies. It is updated every time data is sent to Google Analytics.


- Cookiecf_clearance
- Duration1 year
- DescriptionCloudflare sets the cookie to manage and verify CAPTCHA challenges, ensuring that legitimate users can access the website while blocking malicious traffic.

Performance cookies are used to understand and analyse the key performance indexes of the website which helps in delivering a better user experience for the visitors.

No cookies to display.

Advertisement cookies are used to provide visitors with customised advertisements based on the pages you visited previously and to analyse the effectiveness of the ad campaigns.

No cookies to display.

Other uncategorised cookies are those that are being analysed and have not been classified into a category as yet.

No cookies to display.

![Cookieyes logo](https://cdn-cookieyes.com/assets/images/poweredbtcky.svg)

![profile photo](https://coach-courses-us.s3.amazonaws.com/users/photos/thumb/67730.jpg?1721412873)


- View AllMark all as read
- Plant 4
    Created with Sketch.
    
    
        
            
                
                    
                    
                    
                        
                        
                    
                    
                        
                        
                    
                
            
        
    
Jorge Armando Cortes Montiel evaluated Task 3.3 as Approved
 about 1 month ago
- Plant 4
    Created with Sketch.
    
    
        
            
                
                    
                    
                    
                        
                        
                    
                    
                        
                        
                    
                
            
        
    
Jorge Armando Cortes Montiel evaluated Task 3.2 as Approved
 about 1 month ago
- Plant 2
    Created with Sketch.
    
    
        
            
                
                    
                    
                    
                        
                        
                    
                
            
        
    
Vivek Maskara evaluated Task 3.2 as A little more
 8 months ago
- Plant 4
    Created with Sketch.
    
    
        
            
                
                    
                    
                    
                        
                        
                    
                    
                        
                        
                    
                
            
        
    
Vivek Maskara evaluated Task 3.1 as Approved
 9 months ago
- Plant 4
    Created with Sketch.
    
    
        
            
                
                    
                    
                    
                        
                        
                    
                    
                        
                        
                    
                
            
        
    
Vivek Maskara evaluated Task 2.9 as Approved
 9 months ago
- Plant 4
    Created with Sketch.
    
    
        
            
                
                    
                    
                    
                        
                        
                    
                    
                        
                        
                    
                
            
        
    
Vivek Maskara evaluated Task 2.8 as Approved
 9 months ago

![avatar](https://coach-courses-us.s3.amazonaws.com/users/photos/thumb/67730.jpg?1721412873)


- Oliver Oliverio
- Settings
- Logout


## Server-Side Programming & Node.js


# 2.9: Authentication & Authorization


- Learning Goals
- Introduction
- Authentication and Authorization
- Basic HTTP Authentication
- API Key-Based Authentication
- Session/Cookie-Based Authentication
- JWT (Token-Based) Authentication
- Open Authorization (OAuth)
- Authentication for myFlix Users
- Authentication in Node/Express Using Passport
- Authentication Logic
- Incorporating Authorization Into Your API Endpoints
- Testing Your Authentication and Authorization
- Summary
- Resources
- Task
- Forum


#### Learning Goals


- Apply principles of authentication to REST API


#### Introduction

Welcome back! In the previous Exercise, you explored the intricacies of business logic and how to fully integrate your database with the rest of your myFlix project using Mongoose models. Now that the pieces of the puzzle have finally come together, it’s time to explore some additional considerations for processing client requests to your API. Notably, you’ll want to look into internet security and how you can keep your API safe from malicious actors and software. After all, you want to keep your data safe!

That’s why, in this Exercise, you’re going to learn how you can authenticate your users and authorize their requests. You’ll finish up by exploring how to implement the appropriate logic into your application code before testing everything out in Postman.

Users today expect the apps they use to be safe and secure, making this an essential step in the development process. Let’s go ahead and get started!


#### Authentication and Authorization

Over the course of this Achievement, you built an API that gives the outside world access to certain pieces of data from your server. You designed your API in such a way as to only make certain operations on the data available, and only through corresponding endpoints (to access the “Users” collection, for instance, you have to go through the “/users” endpoint). Operations without a specific endpoint were unavailable (e.g., end users can’t add or delete movies from your API—this can only be done manually from within the database itself).

Based on what you’ve coded so far, the data you have exposed from your web server is publicly accessible to anyone who knows the URL endpoints. You haven’t added anything to restrict who can access your API, nor have you implemented any means of verifying a client’s identity.

Authentication and authorization are two closely related concepts that refer to controlling who has access to which parts of your API. Authentication is the process of verifying a client’s identity, whereas authorization is the process of verifying that a client is allowed to take a certain action. While it’s possible to authorize a client without authenticating them (anonymous clients who don’t provide an identity could be authorized for certain actions), authentication and authorization usually go hand-in-hand.

![Authentication vs. Authorization](https://images.careerfoundry.com/public/courses/fullstack-immersion/A2/E9/authentication_vs_authorization.jpg)


###### Figure 1

Let’s take a look at a real-world example to better demonstrate the difference. Consider a digitized school database containing student grades. Both teachers and students could be authenticated to access the database, which is what lets them through the door, so to speak, but the teacher and student users could be authorized to take different actions and submit different requests. For example, a teacher could be authorized to read all student grades, as well as add, update, and delete them (read and write access), but a student should only be authorized to read their own grades, and they shouldn’t be able to add, update, or delete any grades. In other words, the student should have read-only access to their records.

Why is this important? Well, try to imagine a world in which anyone could have access to any API. Private information on the internet would be readily accessible to everyone! For instance, strangers and malicious applications could query a calendar API that stores personal information about its users’ schedules to learn all about its users’ appointments, their addresses, and other personal information. They could even change users’ data without them knowing! Making sure that clients are properly authenticated and authorized for each action they want to take is essential, especially when dealing with sensitive data in the banking, financial, and medical sectors.

Note that here, the word “client” refers to the frontend program or application that’s making requests to your API (the server-side of your application). This could be a website in the browser, a mobile or desktop app, a command-line tool, Postman, or any other type of software. This is in contrast to the term “user,” which refers to the individual, human person that’s using the client application. Normally, a client application is authenticated and authorized by way of its user’s identity, which the client sends alongside requests to your API.

For your myFlix API, you programmed CRUD operations for reading data about movies, as well as for creating, updating, and deleting data about users. Ideally, you’d want to create a solution where only registered users can “READ” data about movies, “UPDATE” their profile, or “DELETE” their profile, but any anonymous client can “CREATE” a new user.

In this Exercise, you’ll explore the following methods for authenticating user requests on your API endpoints:


1. HTTP authentication
1. API key-based authentication
1. Session/Cookie-based authentication
1. JWT/Token-based authentication

Where relevant, you’ll also look into how each method of authentication corresponds to granting users authorization for different requests on your API endpoints. Through all of this, you’ll want to keep in mind the different levels of security that each method provides, as well as how you can weigh the importance of providing that level of security against the work involved and the efficiency of each approach. At the end of this Exercise, you’ll implement both basic HTTP authentication and JWT/Token-based authentication into your myFlix API and be able to discuss why this was the most appropriate approach for your project.


#### Basic HTTP Authentication

The process of authentication checks whether a client and its user are who they say they are. With basic HTTP authentication (the simplest form of authentication), this is done via usernames and passwords.

During basic HTTP authentication, the client provides a username and password (by way of the user) encoded within the header of the HTTP request it sends to your API. Your API then reads that username and password to check if the user is registered. The syntax for this would look something like:


```js
GET /securefiles/ HTTP/1.1
Host: www.httpwatch.com
Authorization: Basic aHR0cHdhdGNoOmY=
```


> Notice the strange combination of random characters above? This aHR0cHdhdGNoOmY is the encoded version of a username and password for the client “httpwatch.” This method of encoding is called Base64, and it’s conducted automatically when using HTTP authorization. Try copy-pasting the string of characters into a Base64 decoder. Do you see a username followed by a password with a colon in-between?

If a registered user were signing into a content management system (the client) and provided their username and password within its interface located at “www.mywebsitesystem.com,” the client would send an HTTP request to the API containing the user’s username and password. The application would check if this username/password combination exists in its database, and, if so, authenticate the user and allow them to log in.

Often, the username and password combination required for basic HTTP authentication can also authorize the client, giving them access to the entire API. (Remember, authorization refers to what a client is allowed to do.) While it would technically be possible to write custom code for your API where different username/password combinations are given authorization to different parts of your application, this would be reinventing the wheel—there are better solutions involving JWT tokens and OAuth for controlling authorization to different parts of your application (which you’ll be looking at later in this Exercise).

Advantages of basic HTTP authentication

The main advantage of basic HTTP authentication lies in its simplicity. It doesn’t require any extra storage mechanism for the username and password as they're transmitted from the client to the API directly in the HTTP header. From there, it’s a fairly straightforward process for your API to read these values and check them against its database of registered users.

Disadvantages of basic HTTP authentication

It's risky to use HTTP authentication as a general authentication scheme (i.e., beyond an initial login request). As the username and password would be sent along with every request, the authentication details are more susceptible to being intercepted, and your application could potentially be exposed to harmful attacks, especially if the connection is insecure.

And, as usernames and passwords don’t expire, an attacker would have permanent access to your API. (You’ll learn more about these types of attacks and connection security in the next Exercise.) Also, even if the connection is secure, verifying the username and password in every single request can result in slow server response time.

Thus, basic HTTP authentication is best kept for an initial login request only. Any requests after this can be authenticated using a different, more secure method.


> There is one use case where it’s more appropriate to continue using HTTP authentication throughout an entire application, and that’s when an application will only be run on an internal network (or intranet). In this case, there’s no large risk of outside attack (the network isn’t accessible over the public internet), nor is speed of the essence, as the number of users accessing the app would be quite limited.

For your myFlix app, you’ll use basic HTTP authentication to authenticate users when they log into your application (they’ll require a username and password); for all requests past the initial login stage, you’ll use a more advanced and secure form of authentication.


#### API Key-Based Authentication

The next form of authentication you’ll be looking into is key-based authentication. API key authentication is similar to basic HTTP authentication, except that it uses an API key (rather than a username and password) to verify a client’s identity. An API key is a unique piece of code assigned to a specific user (which, to reiterate, could be any individual whose identity persists between usages of the client application) and is usually a long string of characters looking something like this:

`003026bbc133714df1834b8638bb496e-8f4b3d9a-e931-478d-a994-28a725159ab9`

This API key is generated by the API the first time a client (and its user) registers with the app. Then, just like the username and password with basic HTTP authentication, the API key would be passed alongside every request from the client to the API. For example, say a curriculum team in an office wanted to use your image server to host images for their online course materials. They’d consistently be making requests to your API to upload new images. If you allowed the team to register for an API key, they could use (or create) an image uploading software that submits this API key automatically with every request to your API, thus authenticating every upload.

![Screenshot of the connection screen on Cyberduck that includes fields for a server, URL, access key ID, and secret access key](https://images.careerfoundry.com/public/courses/fullstack-immersion/A2/E9/Cyberduck%20connection%20screen.png)


###### Figure 2. The program Cyberduck allows you to connect to a remote server and upload files. Here, you can see the connection screen for the Amazon Cloud Server, which requires a server name, URL endpoint, and access key ID to connect. It additionally requires a “secret access key” for even greater security.

With API key-based authentication, the API key is transmitted within the request headers, similar to how usernames and passwords are transmitted in HTTP authentication. Rather than `Basic aHR0cHdhdGNoOmY=`, like you saw above, you’ll see `Apikey` followed by the API key itself:

`Authorization: Apikey 1234567890abcdef`

While this is the most common way for an API key to be transmitted from a client to an API, there are a few other methods you may run into:


- Adding query strings to the URL endpoints themselves (e.g., a request made to the URL "apiname.com/movies&apikey=003026bbc133714df1834b8638bb496e-8f4b3d9a-e931-478d-a994-28a725159ab9"); this isn’t ideal as it’s relatively easy for a URL endpoint to be intercepted by a third party
- Creating a custom header in an HTTP request
- Inserting into the body of the HTTP request

As you can see, basic HTTP authentication and API key-based authentication are very similar; the former uses a username and password for authentication, while the latter, an API key. Why would you use one over the other? Well, using an API key does bring with it a few additional benefits over basic HTTP authentication: 1) an API key is harder to guess and, therefore, less likely to be intercepted; and 2) it’s usually faster for your API to verify an API key than a username/password combination.

Limitations of API key-based authentication

Although API key-based authentication has some additional benefits over basic HTTP authentication, there are still a few limitations with this approach.

First, if a request containing the API key is intercepted by an attacker, the attacker will now have permanent access to your API. This is because API keys generally don’t expire or designate a specific time frame during which its sender (the user of the client application) is given access to your API.

Second (and similar to basic HTTP authentication), API keys typically give users of the API authorization to perform all operations within an application. (Remember that authentication refers to verifying clients’ identities, whereas authorization refers to controlling access to different parts of your application). While it would technically be possible to have different API keys receive authorization to different parts of your API, as mentioned earlier, this would be reinventing the wheel—there are better solutions involving JWT tokens and OAuth.

Thus, while more secure than basic HTTP authentication, API keys are still not the best choice when it comes to authentication and authorization for most web applications and APIs. The best use case would be an application that only provides users with read-only access to certain data—not write access. In more technical terms, this would mean only allowing users to submit “READ” requests—not “CREATE,” “UPDATE,” or “DELETE” requests. This would decrease the risk of an attacker intercepting an API key and using it to alter your API’s data. Even then, this approach wouldn’t work for APIs that expose sensitive data (like medical or financial records) because the data would still, ultimately, be readable.

With those two methods out of the way, let’s take a look at an even better option.


#### Session/Cookie-Based Authentication

Session-based authentication (also known as cookie-based authentication) involves the creation of a session ID that can be used to authenticate users. After a user makes an initial login request to an application via a client, the server creates a session for that client, then sends back a session ID. The client stores this session ID in the user’s browser as a cookie. The server, meanwhile, stores the session ID “in-memory” (i.e., not in an external database). This approach can also be used for authorization, as the server could additionally map information about what parts of the application the client should be able to access with their session ID.

![Cookie-Based Authentication and Authorization](https://images.careerfoundry.com/public/courses/fullstack-immersion/A2/E9/cookie_auth.jpg)


###### Figure 3

As long as the user remains logged into the session, the client will send along the cookie with the session ID in every proceeding request to the server. The server compares the session ID of the cookie with the one it has stored in-memory in order to authenticate the user’s identity and authorize their access.

Think about, for example, when a user visits a music playlist web application. When the user logs in via the interface in the browser, the client-side makes a request to its API. At this point, the server generates a session for that user and sends back a session ID to the client as a response, which the client (in the browser) saves as a cookie. Each time the user performs an action on the music playlist web application, such as attempting to add a song to their playlist, the client-side makes an additional request to the API, passing along the cookie, which the API and server use to authenticate the user’s identity.

Unlike the previous two approaches (basic HTTP authentication and API key), with a session-based approach, the session ID provided to the client will eventually expire—both on the server-side (since a session won’t be saved in the server memory forever) and on the client-side (since cookies aren’t stored in the browser forever). Once the session ID of the user for the music playlist app expires, the user would be logged out and no longer able to modify their playlist without logging back in (and receiving a new session ID).

You’ve probably experienced this yourself. Have you ever cleared the cookies from your browser to find you've been logged out of your friend’s Netflix account? This process clears the session ID you would have had stored for Netflix on the client-side. If you were to try and load the site again, you’d be logged out of the application and no longer able to make requests from Netflix’s client-side to Netflix’s server-side (to watch a movie, for example). This is because Netflix’s server-side would no longer be able to authenticate your identity via the cookie in your browser. If it can’t find your session ID, you’re out of luck (and will have to ask that friend for their password again)!

Sometimes, however, you find yourself logged out of an app even when you haven’t manually cleared your cookies. When this happens, it’s likely because the session ID stored by the server has expired.

The simple fact that session IDs can expire makes session-based authentication safer than HTTP- or API key-based authentication. Even if an attacker were to intercept a request made with a session ID, they wouldn’t have permanent access to the application; thus, any damage would be limited.

Limitations of session/cookie-based authentication

This approach does come with its own limits, however, especially on the server-side. As the server has to store a separate session ID for each client (including information about what that client should have access to), and additionally cross-check that session ID every time the client makes a request, coding, processing, and response times could suffer.

This is exactly why you’ll be using the next approach—JWT (token-based) authentication—for your Achievement project. It addresses the speed, scalability, and security-based concerns that remain with session-based, API-key, and basic HTTP authentication. Let’s take a look!


#### JWT (Token-Based) Authentication

JWT—JSON Web Token—is a JSON-based standard for creating web tokens that can be used for authentication (and authorization). Because it addresses some of the flaws already mentioned in the previous approaches, it’s become the de facto standard for most modern web applications. Before we explore how it avoids those flaws, let’s take a look at the flow of JWT authentication to see how it works.

With JWT authentication, the client makes a request to the server-side of an application, after which the server generates a web token that represents an encoded version of some claim—for instance, the client’s identity, what the client should have access to, and for what length of time they should be allowed access to it—and sends this token back to the client. The client stores this JWT and sends it alongside every subsequent request to the API, where the server then validates it in order to verify the client’s identity and process its requests.

![JWT Token-Based Authentication and Authorization](https://images.careerfoundry.com/public/courses/fullstack-immersion/A2/E9/jwt_auth.jpg)


###### Figure 4

The code for generating a JWT is a string that takes the following syntax:

`[Encoded header].[Encoded payload].[Encoded signature]`

The “header” component contains information about the type of token (which, in this case, is JWT)  and the algorithm used to encode it. The “payload” is the content of the JWT itself—for instance, any claims about the client and its user, as well as what they should have access to. The “signature” at the end is a type of verification. It’s used to confirm that the sender of the JWT (the client) is who they say they are, and that the JWT hasn’t been altered.

The server normally generates the JWT by way of a secret key that encodes the three pieces of information above. Because only the server itself knows this key, the encoding can’t be decrypted like the basic Base64 encoding used for HTTP authentication. The final JWT would look something like this:

![A long series of random letters and numbers separated by two periods into three parts](https://images.careerfoundry.com/public/courses/fullstack-immersion/A2/E9/JWT%20example.png)


###### Figure 5


> You won’t need to worry too much about generating your own JWT. For your myFlix app, you’ll use a middleware library called Passport to generate JWTs for you!

Once the JWT is sent back to the client, the server’s work is done. The client stores the JWT locally, usually via something called “local storage” in the browser (you’ll learn more about storage on the client-side in the next Achievement). The client then sends the JWT alongside future HTTP requests to the API, typically in the “Authorization” header of the requests—specifically, a header called “Bearer.” The content of the header would look something like this:

`Authorization: Bearer <token>`

The server reads the JWT and decodes it using its secret key. Once decoded, it can be used to authenticate and authorize the client for the requested action. The JWT may additionally contain information about its own expiration time. This creates even less work for the server, as it doesn’t need to keep track of when each client’s access expires (as it would for session-based authentication).

Overall, JWT authentication makes for less burden on the server, and therein lies the main difference between JWT and session-based authentication. With JWT authentication, the server doesn’t store any information in-memory; the JWT token is “self-sufficient.” You can think of it a bit like a child. When a child is young, they're not self-sufficient. Their parents need to provide things that the child can’t provide on their own. This is like session-based authentication, where the server needs to store and provide information about a client in its memory. Once a child grows up, however, they become self-sufficient and no longer need their parents to provide things for them. This is like JWT authentication—rather than the server having to store information on the client in its memory, the JWT contains all that information itself. Thus, there’s little to no “heavy lifting” required on the server-side, leading to a more scalable solution.

For these reasons (speed, security, and less strain on the server-side), JWT token-based authentication tends to be the more favored form of authentication amongst web apps.


#### Open Authorization (OAuth)

Before moving onto authentication and authorization for your myFlix project, let’s look at one more option that’s become increasingly popular in recent years. Note, though, that this option doesn’t provide an alternative to the methods explored thus far; rather, it offers a framework to do so in a slightly different manner.

Open Authorization, or “OAuth,” is an authentication and authorization framework that allows third party applications to authenticate clients without the need for clients to share credentials directly with the server. Instead, clients are authenticated and authorized via a secure, third party service.

The best example of this is when you go to sign into a website and are offered a number of options for how to do so. For example, you may be given the option to sign in with Google, Facebook, or Twitter. These three sites can act as third party services through which you can be authenticated, giving you access to the original website.

![Screenshot of the sign-in page for Medium, including Google, Facebook, Twitter, and email options](https://images.careerfoundry.com/public/courses/fullstack-immersion/A2/E9/Medium%20signin%20page.png)


###### Figure 6. Medium’s sign in options: Google, Facebook, Twitter, and email.

While it’s true that OAuth provides an alternative authentication framework via one of the third party services mentioned above, when it comes down to it, it’s still using one of the same authentication and authorization methods explored above. For example, OAuth usually employs a JWT to authenticate users. If you picked Facebook as the third party service to log in to Medium, Facebook would share your Facebook JWT with Medium, which would contain your authentication and authorization information and allow you to log into the site.


> It’s important to note here that you shouldn’t ever fully rely on third party authentication (i.e, you should always offer an alternative, such as email, as well). For one, you may have users that don’t have an account on any of the offered third party services. Still other users like to keep their accounts separate. After all, in an era where more and more social media services are sharing or selling data, keeping your usage of other sites and apps safe from Facebook’s grasp can help keep your online activity more private.


#### Authentication for myFlix Users

Now that you’ve explored the main options for authentication (and authorization) applications, let’s discuss which of the methods you’ll be implementing in your own project and why. For your myFlix API, you’re going to use both basic HTTP authentication and JWT-based authentication.

Your initial user authentication will be handled by basic HTTP authentication. For instance, when registered users make a login request, they’ll provide a username and password, which will be sent within the header of the HTTP request. Then, as a result of the initial login request and authentication, your application will generate a JWT for the user. This will allow subsequent requests to be authenticated and authorized with JWT-based authentication.

![Authentication and Authorization for myFlix](https://images.careerfoundry.com/public/courses/fullstack-immersion/A2/E9/myflix_auth.jpg)


###### Figure 7

Each endpoint in your API will require the user’s JWT in order to authorize a request (i.e., only authenticated users—those with a token—will be authorized to make requests at each endpoint). If a user’s login request wasn’t authenticated, and they subsequently weren’t issued a token, they’d be unable to make any requests to your API.

Authenticated users will be able to submit their token alongside every request they make to each endpoint. For instance, if a logged in and authenticated user (who’s been assigned a token) wanted to add a new movie to their list of favorites, this request would be accompanied by that user’s JWT, which would be verified (and authorized) at each endpoint.

Of key note, here, is that basic HTTP authentication will only be used to verify registered users. In order to authenticate a user, they need to already have registered. After all, if they haven’t registered, their username and password combination won’t exist in the user registration details in your database (in your “Users” collection). For brand-new users, you don’t need to take any authentication measures. In fact, you can’t! You need to allow anonymous users to create new accounts (i.e., to register) or else you’d never never get any new users.


#### Authentication in Node/Express Using Passport

Now that you’ve learned about a few different types of authentication and looked into which of them you’ll be using for your Achievement project, let’s explore how to integrate authentication into your myFlix API. You’ll do so using a tool called Passport.

Passport is an authentication middleware for Node.js and Express. It uses blocks of code called strategies to enable certain means of authentication and authorization multiple times throughout your application. Strategies can range from basic HTTP authentication to JWT-based authentication and third party OAuth with specific providers such as Facebook and Google.

For your API, you’ll use Passport to implement basic HTTP authentication to log registered users into your application, as well as JWT authentication for subsequent requests to your API.


##### Installing Passport and Configuring Passport Strategies

The first thing you need to do is install Passport itself, followed by the libraries for the authentication methods you want to use. In your case, you want to install HTTP authentication and JWT authentication packages locally (using the `--save` flag so that the packages are added to “package.json”). You need to run four commands in your terminal, as follows:


```js
npm install passport

npm install passport-local

npm install passport-jwt

npm install jsonwebtoken
```

Here’s what each line does:


- First line: Installs the main passport library.
- Second line: Installs the passport strategy for authentication.
- Third line: Installs the passport strategy for JWT authentication.
- Fourth line: Installs the jsonwebtoken library for basic HTTP authentication (username/password) and continuous authorization.

Alternatively, you can simply run a single command to install all four packages:

`npm install passport passport-local passport-jwt jsonwebtoken`.

Next, you need to configure your Passport strategies. To do so, create a new file in your application folder called “passport.js”. Below is the block of code you’ll want to add to this file, but we strongly advise you to type it out rather than copy-pasting the entire block. The next section will break the code down piece-by-piece. As you read through and understand what each section of the code is doing, type the code into your own file. This will give you more experience actually writing new code and ensure that you know what you’re writing.


```js
const passport = require('passport'),
  LocalStrategy = require('passport-local').Strategy,
  Models = require('./models.js'),
  passportJWT = require('passport-jwt');

let Users = Models.User,
  JWTStrategy = passportJWT.Strategy,
  ExtractJWT = passportJWT.ExtractJwt;

passport.use(
  new LocalStrategy(
    {
      usernameField: 'Username',
      passwordField: 'Password',
    },
    async (username, password, callback) => {
      console.log(`${username} ${password}`);
      await Users.findOne({ Username: username })
      .then((user) => {
        if (!user) {
          console.log('incorrect username');
          return callback(null, false, {
            message: 'Incorrect username or password.',
          });
        }
        console.log('finished');
        return callback(null, user);
      })
      .catch((error) => {
        if (error) {
          console.log(error);
          return callback(error);
        }
      })
    }
  )
);


passport.use(new JWTStrategy({
  jwtFromRequest: ExtractJWT.fromAuthHeaderAsBearerToken(),
  secretOrKey: 'your_jwt_secret'
}, async (jwtPayload, callback) => {
  return await Users.findById(jwtPayload._id)
    .then((user) => {
      return callback(null, user);
    })
    .catch((error) => {
      return callback(error)
    });
}));
```

In this code, two Passport strategies are defined. The first one, called “LocalStrategy,” defines your basic HTTP authentication for login requests. `LocalStrategy` takes a username and password from the request body and uses Mongoose to check your database for a user with the same username—keep in mind that the password doesn't get checked here. You'll be working on that in the next Exercise. If there’s a match, the callback function will be executed (this will be your login endpoint, which you’ll be exploring further in the next section).

If an error occurs, or if the username can’t be found within the database, an error message is passed to the callback:

`return callback(null, false, { message: 'Incorrect username.' })`

Setting up the JWT authentication code is a bit more complicated. This strategy is called, appropriately, “JWTStrategy,” and it allows you to authenticate users based on the JWT submitted alongside their request. In the code above, the JWT is extracted from the header of the HTTP request. This JWT is called the “bearer token” (you’ll see how this bearer token is submitted in a bit):

`jwtFromRequest: ExtractJWT.fromAuthHeaderAsBearerToken(),`

You also need to use a “secret” key to verify the signature of the JWT. As mentioned earlier, this signature verifies that the sender of the JWT (the client) is who it says it is—and also that the JWT hasn’t been altered.

`secretOrKey : 'your_jwt_secret'`

With your JWT code set up, you can now use JWT authentication for the rest of the endpoints in your API. When registered users want to read movie data, for example, you can write logic that will authenticate them based on the JWT submitted in their `GET` requests.


#### Authentication Logic

Now that you have your Passport strategies in place, you can create the actual logic that will authenticate registered users when they log in using their username and password (basic HTTP authentication), as well as generating a JWT that will authenticate their future requests.

So far, however, you only have an API endpoint for new users to register, or “CREATE,” an account using a username, password, and other user details stored in the “Users” collection in your database. You don’t yet have an endpoint that allows for existing, registered users to log in. You’ll need this endpoint in order to implement basic HTTP authentication for login requests.

The first thing you need to do is create a new endpoint for the API with the URL “/login”. You could technically add this endpoint alongside your other endpoints, but since you’re going to implement special authentication measures for this request, let's put the endpoint in a separate file, called “auth.js” (for “authentication”).

With the code you write in this file, you’ll be able to create a new endpoint for registered users to log in. This code will authenticate login requests using basic HTTP authentication and generate a JWT for the user. Write the code below in the new file you just created. You’ll notice each section has been explained via inline comments. As always, we strongly advise against copy-pasting as actually writing out each line will give you more experience working with the new code.


```js
const jwtSecret = 'your_jwt_secret'; // This has to be the same key used in the JWTStrategy

const jwt = require('jsonwebtoken'),
  passport = require('passport');

require('./passport'); // Your local passport file


let generateJWTToken = (user) => {
  return jwt.sign(user, jwtSecret, {
    subject: user.Username, // This is the username you’re encoding in the JWT
    expiresIn: '7d', // This specifies that the token will expire in 7 days
    algorithm: 'HS256' // This is the algorithm used to “sign” or encode the values of the JWT
  });
}


/* POST login. */
module.exports = (router) => {
  router.post('/login', (req, res) => {
    passport.authenticate('local', { session: false }, (error, user, info) => {
      if (error || !user) {
        return res.status(400).json({
          message: 'Something is not right',
          user: user
        });
      }
      req.login(user, { session: false }, (error) => {
        if (error) {
          res.send(error);
        }
        let token = generateJWTToken(user.toJSON());
        return res.json({ user, token });
      });
    })(req, res);
  });
}
```

The code above first uses the the `LocalStrategy` you defined in the previous section to check that the username and password in the body of the request exist in the database. If they do, you use the `generateJWTToken();` function to create a JWT based on the username and password, which you then send back as a response to the client. If the username and password don’t exist, you return the error message you receive from`LocalStrategy` back to the client.

As you can see from the `generateJWTToken();` function, the JWT is given an expiration date of seven days. This means that, after seven days, a user’s session will end, and they’ll need to log in again (i.e., have their username and password authenticated again and be assigned a new JWT).

Please also pay attention to the line of code that returns the token:


```js
return res.json({user, token});
```

This is, in fact, ES6 shorthand for `res.json({ user: user, token: token })`. With ES6, if your keys are the same as your values, you can use this shorthand.

Before finishing up, remember to import your “auth.js” file into your project. To do so, add the following code to your “index.js” file. Be sure to place it AFTER your bodyParser middleware function (app.use(bodyParser.urlencoded({ extended: true }));):


```js
let auth = require('./auth')(app);
```

Please note the `app` argument you're passing here. This ensures that Express is available in your “auth.js” file as well.

You also need to require the Passport module and import the “passport.js” file. To do so, add the following code to your “index.js” file after `let auth = require('./auth')(app);`:


```js
const passport = require('passport');
require('./passport');
```


#### Incorporating Authorization Into Your API Endpoints

You now have the logic in place for authenticating users as they log in, as well as for generating a JWT for them. But what about the rest of your endpoints? In the previous Exercises, you defined multiple endpoints in your API for creating, reading, updating, and deleting data about users and reading data about movies. You’ll want to ensure only authenticated users are authorized to access these endpoints. For example, only users who’ve registered and been authenticated should be able to read movie data, create a list of favorite movies, update their username, and delete their account (amongst other actions).

For this, you need to apply the JWT authentication strategy to more of your endpoints. This way, only users with a JWT in their request headers will be able to make requests. What this boils down to is coding each endpoint to ask for a token whenever a request to it is made. Once it receives the token from the client, it decodes it, then compares the authentication and authorization details it contains with the details stored in the database. If everything matches up, the request to the endpoint will go through.

To apply JWT authentication to a specific endpoint, you need to pass it as a second parameter between the URL and callback function. Take a look at the code below, which is a `GET` request to the “/movies” URL:


```js
app.get('/movies', passport.authenticate('jwt', { session: false }), async (req, res) => {
  await Movies.find()
    .then((movies) => {
      res.status(201).json(movies);
    })
    .catch((error) => {
      console.error(error);
      res.status(500).send('Error: ' + error);
    });
});
```

As you can see, the `GET` request now has three parameters: the URL, the `passport.authenticate('jwt', {session: false})` function, and the callback function. Now, any request to the “movies” endpoint will require a JWT from the client. The JWT will be decoded and checked by the JWT authentication strategy you created earlier using Passport, which will  authenticate the request.

In this code, you’re using a single token to authorize access to all of your endpoints (rather than using different tokens that authorize access to different parts of your app). Thus, the token wouldn’t contain any specific information about what endpoints the user is authorized to access. If you were creating a more complicated application, however, this multi-token approach would not only be possible, but common.


#### Testing Your Authentication and Authorization

Now that you’ve implemented your code, the first thing you’ll want to do is test that you’re no longer authorized to access the API endpoints you created. After all, you aren’t an authenticated user!

In Postman, try making a general `GET` request to the “/movies” endpoint. You should receive a response that looks like this:

[](https://images.careerfoundry.com/public/courses/fullstack-immersion/A2/E9/Unauthorized%20GET%20request%20in%20Postman.png)


###### Figure 8 (Click to Zoom)

Hopefully, you'll receive the message “Unauthorized”; otherwise your JWT authentication isn’t working! Even though you created the endpoints, you don’t have a username and password within the database, nor have you ever logged in and received a JWT. Thus, you’re being blocked from making a request on the “/movies” endpoint. In order to get your own authenticated JWT and access the endpoints in your API, you’ll need to do the same thing as your users: register.

To do this, start by submitting a `POST` request to the “/users” endpoint that includes a new username and password:

[](https://images.careerfoundry.com/public/courses/fullstack-immersion/A2/E9/post_new_user.png)


###### Figure 9 (Click to Zoom)

Next, submit another `POST` request to the new login endpoint you created earlier, only this time, rather than sending along a JSON body, you’ll be sending along “parameters.” Click the Params or Body tab on the far left (passport already knows to look for the user credentials within the request’s parameters and body), where you’ll be given a table of key-value pairs you can enter. Start by typing “Username” in the first key field, followed by the username of the user you just posted in the value field. Underneath this, type “Password” in the next key field, followed by the password of the user you just posted in its value field. You’ll notice that the URL endpoint updates automatically to include the username and password. This will authenticate your identity via basic HTTP authentication and assign you a JWT:

[](https://images.careerfoundry.com/public/courses/fullstack-immersion/A2/E9/login_endpoint_keys_values.png)


###### Figure 10 (Click to Zoom)

You should receive a response with the details of the user and, beneath everything, a new “token” field. This is your JWT! You should now be able to make your original request once again. Resend your `GET` request to the “/movies” endpoint, this time passing along your JWT by clicking on Authorization, selecting Bearer Token from the Type dropdown menu, then entering your JWT token into the field:

[](https://images.careerfoundry.com/public/courses/fullstack-immersion/A2/E9/bearer_token_authorization.png)


###### Figure 11 (Click to Zoom)

Once you’ve passed along your JWT and have been authenticated by your app, you should receive the data you requested—all the movie data within your database! Pretty neat, right?

Now, if you try to submit a `PUT` request to the API endpoint that “allows users to update their user info”, you’ll notice that any registered/logged-in user—after the JWT has been pasted into the Token field—can potentially modify other user data by username. Therefore, it’s best to add a condition that checks and makes sure that the username in the request body matches the one in the request parameter. Check out the following example for the `index.js` file:


```js
app.put('/users/:Username', passport.authenticate('jwt', { session: false }), async (req, res) => {
    // CONDITION TO CHECK ADDED HERE
    if(req.user.Username !== req.params.Username){
        return res.status(400).send('Permission denied');
    }
    // CONDITION ENDS
    await Users.findOneAndUpdate({ Username: req.params.Username }, {
        $set:
        {
            Username: req.body.Username,
            Password: req.body.Password,
            Email: req.body.Email,
            Birthday: req.body.Birthday
        }
    },
        { new: true }) // This line makes sure that the updated document is returned
        .then((updatedUser) => {
            res.json(updatedUser);
        })
        .catch((err) => {
            console.log(err);
            res.status(500).send('Error: ' + err);
        })
});
```

If this part of your app’s authentication and authorization infrastructure isn’t addressed, your users could experience significant security breaches. Another user would be able to modify or manipulate the data of other users without proper authorization or access privileges. As a developer, you need to be aware that allowing unauthorized modification of user data is a significant security flaw that can have severe consequences, as well as possible legal implications. Proper security measures, including authentication mechanisms, should be implemented to prevent such unauthorized modification.


#### Summary

In this Exercise, you explored a few popular options for incorporating authentication and authorization methods into applications. You looked into basic HTTP authentication, API key-based authentication, session-based (or cookie-based) authentication, JWT token-based authentication, as well as OAuth, and you considered the pros and cons of each.

You then explored, more specifically, authentication and authorization methods for your myFlix API. You ended up implementing basic HTTP authentication for your initial login requests and JWT authentication for future requests to your API using a middleware tool called Passport. Finally, you tested your new authentication and authorization methods using Postman.

Great job! Not only do you have a working API and database, but you can also ensure that your API endpoints are secure and the data in your database isn’t being divulged to every would-be hacker on the internet. The backend to your myFlix app is really starting to look polished now! In the next Exercise (and the last Exercise of this Achievement), you’ll look into even more ways to keep your data secure, including password algorithms and external storage. You’ll also learn about important data security laws you need to keep in mind as a developer: namely, GDPR and other data-collecting regulations!

But first, let’s make sure your myFlix API has been equipped with the authentication and authorization methods you learned in this Exercise.


#### Resources

If you’re curious to read more about the topics covered in this Exercise, then we recommend taking a look at the resources below. Note that this reading is optional and not required to complete the course.

Authentication Methods:


- Authentication Defined
- API Keys vs. OAuth Tokens vs. JSON Web Tokens
- Session vs. Token-Based Authentication
- Differences Between Authentication and Authorization

Open Authorization (OAuth):


- What is OAuth? How the Open Authorization Framework Works
- What the Heck is OAuth?
- What is OAuth? Definition and How it Works

HTTP Authentication:


- HTTP Authentication

Passport.js:


- Passport.js
- Passport Documentation
- Learn Using JWT with Passport Authentication

Take the quiz to test your knowledge on this Exercise.


#### Task


- Direction
- Submission History

In this Exercise, you learned about the importance of authentication and authorization, along with a few different means of applying it in web applications. Let’s now apply what you’ve learned to your myFlix API.

Directions:


1. Install the necessary packages/libraries for basic HTTP authentication and JWT authentication with Passport.
1. Create a new file, “passport.js”, in your project directory.
1. In this file, define your two authentication strategies: “LocalStrategy” and “JWTStrategy.”
1. Create a new file, “auth.js”, in your project directory.
1. In your new “auth.js” file, create a new “/login” endpoint for registered users that contains logic for authenticating users with basic HTTP authentication and generating a JWT token for authenticating future requests.
1. Add the following code to your “index.js” file to ensure your application can make use of your “auth.js” file, and that your “auth.js” file can use Express: let auth = require('./auth')(app);
1. Integrate your two Passport strategies as middleware into each of your existing API endpoints so that only users with a JWT token can make requests to your API.


Remember to exclude the API endpoint for “adding a new user.” If added, your app’s users will be restricted from registering due to the authentication measures applied.
1. Test each method using Postman and take screenshots documenting each test.
1. Update your project directly on GitHub, then create a zip file of your project repository on your computer.
1. Submit a link to your project here, along with the zip file of your repository and a PDF or zip file containing your test result screenshots, for your tutor to review.

Rubric

Refer to the categories below to see how to meet the requirements of the approved stage

![](https://cdn.careerfoundry.com/assets/rubrics/not_yet-c9fb80e521507759d546f847f8a65a00c66f2c8ec7ece4e37f98c25aa122778c.svg)


- Submission is missing complete files, for instance, a “passport.js” file or “auth.js” file, and no Passport strategies have been integrated into existing API endpoints; OR
- “passport.js” file and “auth.js” files are included but missing large sections of code, OR
- Passport strategies haven’t been integrated into all existing API endpoints; OR
- No file of screenshots has been included in the submission

![](https://cdn.careerfoundry.com/assets/rubrics/almost_there-f4bb1c077a0a826e7d4e3ecb72859fc401d362d9bd49c0658f4fd85c4a047a87.svg)


- “passport.js” file includes a LocalStrategy and JWTStrategy, but there are issues in the code; AND
- “auth.js” file includes a “/login” endpoint, but there are issues in the code; AND
- Passport strategies have been integrated into existing API endpoints, but there are issues in the code; AND
- File is included with screenshots of each method tested in Postman

![](https://cdn.careerfoundry.com/assets/rubrics/approved-7dfdcf59318cf52fcbd1333d8b71bf7a2bde35b6e0b753ac975349982495e0b4.svg)


- A new “passport.js” file has been added to the project that includes a LocalStrategy and JWTStrategy
- A new file “auth.js” has been added to the project that includes a “/login” endpoint for authenticating users and generating JWT tokens
- Passport strategies have been integrated into existing API endpoints
- File with screenshots of each method tested in Postman is included

Questions for this task

Student Submissions

Check out recently submitted work by other students to get an idea of what’s required for this Task:

EVALUATION COMPLETE

![](https://coach-courses-us.s3.amazonaws.com/users/photos/thumb/51945.jpg?1660008090)

Vivek Maskara

Oct 04, 2024 at 12:06 AM

Hi Oliver,

Thanks for submitting the assignment.

It looks great and meets all the requirements for the task.

Kudos on implementing both the auth strategies and testing them correctly. 🎉

Things you did great:


- Correctly implemented the local and the JWT auth strategy
- Used the Passport strategies as middlewares.
- Added /login in auth.js
- Screenshot shows successful API response when token is passed in request.

Checkout these resources for further reading:


- Video: OAuth Login Passport.js Tutorial #1 - What is OAuth?
- Passport Strategies
- Node.js Cheat Sheet
- Your Node.js Authentication Tutorial is Wrong

Great job!

Feel free to drop me a message if you have any follow up questions.

Best,
Vivek


- Plant 1
    Created with Sketch.
- Plant 2
    Created with Sketch.
- Plant 3
    Created with Sketch.
- Plant 4
    Created with Sketch.

Approved

![Lauren, Sarah, Korina, CareerFoundry Student Advisor](https://images.careerfoundry.com/public/team/student_advisors_july_2020.jpg)

Student Advisors

How was Vivek’s feedback throughout this exercise?

Does this feedback help you understand what you did well and how you can improve?

How motivated do you feel after receiving the feedback from your tutor/mentor?

Did your mentor or tutor respond within the expected timeframe? (24hrs for tutors; 48 hrs for mentors)

![](https://coach-courses-us.s3.amazonaws.com/users/photos/thumb/67730.jpg?1721412873)

Oliver Oliverio  Submitted Something for Task 2.9

Oct 02, 2024 at 05:15 PM

submitting task 2.9.  See `Task2.9_Authentication/Screenshots` to see postman tests


#### Forum

The Forum is a place to ask questions about the Exercise and share resources with other students. To share feedback on the Exercise content directly with the CareerFoundry team, please click on the “Give us feedback!” button at the end of the Exercise.


###### Help us improve this course! Please take a moment to answer some questions about this Exercise:

Is the instruction in this Exercise clear and straightforward?

How confident do you feel in your ability to apply the skills learned in this Exercise in the workplace?

How likely would you be to recommend the tools/resources provided in this Exercise to a friend or colleague?

Any comments you'd like to add?




- 
- Don't share with my mentor

AI Explain

Make note
